# Js-Algo-1
(닉네임뭐하지 제작)

## 개요
> 어느날 수상한 메일이 도착했습니다. 무슨 내용인지 찾아내실 수 있으신가요?

자바스크립트 코드를 분석해서 플래그를 찾아보세요. 플래그 형식은 `flag{...}`입니다. 

힌트: ![hint](./Algorithm.jpg)

## 의도한 풀이
> 출제의도 : 자바스크립트로 작성된 알고리즘을 분석하기

### 문제 분석
파일을 열어보면 0부터 F까지의 입력을 할 수 있는 버튼이 있고, 입력값을 확인할 수 있는 버튼이 있습니다. 입력 버튼을 누르면 해당 값이 변수 `input`에 저장되고, `<p>`태그를 통해 사용자에게 보여집니다. 

임의의 값을 넣어보면 아니라는 경고창이 뜹니다. 특정 조합을 입력해야 플래그를 볼 수 있음을 추측할 수 있습니다. 

입력을 위한 버튼을 누르면 `addvalue` 함수가, 확인 버튼을 누르면 `validate` 함수가 실행됩니다. 

`addvalue` 함수는 매개변수로 특정 문자열을 받아서 `input` 변수에 추가한 후 화면에 출력하는 기능을, `validate` 함수는 `input` 변수를 어떤 함수에 전달한 후 6c0a~~ 값과 비교하고 있습니다.

0부터 F의 값을 입력받고, 어떠한 연산을 거쳐서 16진수 문자열로 보이는 것과 비교하는 것을 볼 수 있습니다. 

### 풀이 방법
편의를 위해 난독화하지 않은 코드를 대상으로 설명을 진행하겠습니다.
(난독화된 파일은 함수 이름과 매개변수의 이름을 바꾸고, 별도의 처리를 하지 않았습니다. )

`validate` 함수의 특정 부분을 자세히 보겠습니다.
```javascript
if (encrypt(input,1) == '6c0a67066a1130556709691a5f31610f40275f337532394d741565047e00007d')
{
    alert(hex2a(encrypt(encrypt(input,1),2)));
}
```
이 부분의 작동 과정을 보면,
1. `encrypt` 함수에 입력과 `1`을 매개변수로 전달하고
2. 이 값이 특정 문자열과 같으면 함숫값을 다시 `encrypt` 함수에 `2`와 함께 전달하고
3. 최종 결과를 `hex2a` 함수로 처리한 후에 
4. 경고창으로 내용을 보여줍니다. 

만약 `encrpyt` 함수에 입력과 `1`을 매개변수로 전달한 값이 특정 문자열과 같지 않다면 틀렸다는 경고창이 뜨기 때문에, 조건문을 통과해야 플래그를 얻을 수 있음을 추측할 수 있습니다. 

그런데 로직을 자세히 보면, **특정 문자열과 함숫값이 같으면 함수값을 매개변수로 전달하는** 것을 볼 수 있습니다. 따라서 `encrypt(input,1)`의 값은 고정되어 있으며, 이때의 값은 소스코드에 그대로 노출된 6c0a~~임을 알 수 있습니다.

그래서 입력값을 어떻게 해야할 지 추측할 필요 없이, 
```javascript
hex2a(encrypt('6c0a67066a1130556709691a5f31610f40275f337532394d741565047e00007d',2));
```
을 실행시키면 플래그를 얻을 수 있습니다.

### 추가로 가능한 풀이
![hint](./Algorithm.jpg)
힌트를 다시 보겠습니다. 

첫번째 줄을 특정 단위로 나누고, 두 번의 연산을 거쳐서 결과를 생성하는 암호화 알고리즘을 설명하고 있습니다. 여기서 첫번째 줄(주황색)은 입력을, 두번째 줄(보라색)은 암호화된 결과입니다. 

그러나 이 암호화 알고리즘은 설계부터 치명적인 취약점을 가지고 있습니다.

1) 우선 암호키를 사용하지 않기 때문에 복호화 방법을 안다면 어떤 문자열이든 같은 방법으로 복호화 할 수 있습니다. 

2) 블록 기반 암호화인데, XOR 연산과 치환 방식만 사용하고 과정의 수도 많지 않기 때문에 암호화 방식을 그대로 역으로 따라가면 원래의 문자열을 구할 수 있습니다.

~~(원래는 첫번째 라운드에서 특정 암호키를 활용해 XOR하는 방식과 암호키의 길이만큼 밀려서 치환하는 방식을 생각했는데 그만뒀습니다. crib을 이용해 복호화 할 수 있으려나요?)~~

따라서 6c0a~~ 가 암호문이라고 생각하면, 그대로 역연산해서 평문을 구할 수 있게 됩니다.

이때 첫번째 라운드 (`round1` 함수)를 보면, 4글자 단위로 패딩을 붙이고 2글자 단위로 묶어서 XOR하는 것을 확인할 수 있습니다. (WORD 단위의 연산입니다)

첫 4개의 글자(6c0a)만 복호화해보겠습니다.

> 1. BYTE 단위로 끊어서 블록을 생각 : [0x6C, 0x0A]
> 2. 두번째 라운드를 역연산 : [0x6C, 0x0A] -> [0x0A, 0x6C]
> 3. 첫번째 라운드를 역연산 : [0x0A, 0x6C] -> [0x66, 0x6C]
> 4. ASCII를 문자열로 변환 : [0x66, 0x6c] -> [f, l]

같은 방식으로 모두 복호화할 수 있습니다.

